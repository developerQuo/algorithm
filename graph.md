# 인접 행렬

# 인접 리스트

# MST

# 이진 트리
완전 이진 트리는 배열로 표현할 수 있지만, 이진 트리는 포인터를 사용한다.
- 전위 순회 (Preorder Traversal): 자신 -> 왼쪽 -> 오른쪽
- 중위 순회 (Inorder Traversl): 왼쪽 -> 자신 -> 오른쪽
- 후위 순회 (Postorder Traversal): 왼쪽 -> 오른쪽 -> 자신

# Union-Find
ex) MST. 노드가 서로 연결되었는지 확인하는 방법. 루트를 찾는 find 함수와 부모를 연결하는 union 함수.
1. 모든 노드의 루트를 자기 자신으로 설정한다.
2. 비교하는 두 노드의 루트를 확인한다.
3. 루트가 다르면 더 작은 쪽으로 나머지 노드의 부모를 연결한다.

# 크루스칼
ex) MST. 최소 가중치의 간선을 차례로 연결. 사이클 확인을 위해 Union-Find를 사용해야 하나?
1. 모든 간선들을 가중치 기준 오름차순으로 정렬한다.
2. 사이클이 형성되었는지 판단하는 사이클 테이블을 만든다.
3. 최소 가중치부터 차례로 사이클 형성여부를 체크하며 노드를 연결한다.

# BFS
ex) 최단거리 찾기. queue이나 이중 for 문 + 재귀
1. 시작노드를 큐에 삽입하면서 시작하고 방문 처리
2. 큐에서 노드를 꺼내서 방문하지 않은 연결된 노드를 큐에 삽입
3. 큐에 노드가 없으면 종료

# DFS
ex) 경우의 수. stack이나 for문 + 재귀
1. 시작노드를 스택에 삽입하면서 시작하고 방문 처리
2. 스택에서 노드를 꺼내서 방문하지 않은 연결된 노드를 스택에 삽입
3. 스택에 노드가 없으면 종료

# 다익스트라
ex) 최단 경로. BFS + 가중치 + 우선순위 큐
O(E log V)
1. 가중치를 노드에 더하기
2. 경우의 수가 생기면 최소값을 가져온다.
3. 가장 작은 가중치로 시작한다. (우선 순위 큐 - 힙)

# 플로이드 마샬
가능한 모든 경우의 수를 최적의 값으로 계산해서 업데이트 
O(n^3)

# 프림
최소값 + 우선순위 큐
MST

# 위상정렬
선행 조건을 지키도록 정렬. 사이클이 있다면 불가능.
1. 들어오는 간선인 in-degree가 0인 정점을 큐에 넣는다.
2. 정점과 연결된 간선을 삭제한다.
3. 1-2 과정을 반복하고 큐를 리턴한다.