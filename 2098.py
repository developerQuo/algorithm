"""
문제: 1에서 N번까지 도시를 한번씩 거쳐 돌아오는 가장 적은 비용을 구하라.
조건
도시간 이동 비용은 W[i][j] 형태로 주어진다.
w[i][j]와 w[j][i]는 다를 수 있다.
w[i][i] == 0
도시 간 이동이 불가능한 경우 비용은 0이다.
2 <= 도시 수 N <= 16

dp에 담을 것
- 구간 별 최소 이동 비용

필요한 인자
- i: 시작 구간
- j: 끝 구간
- k: 분할 지점

dp 배열의 인덱스 의미
dp[i][j]: i부터 j구간까지 최소 이동 비용

Reduction
1. k로 구간을 나눈다.
2. 구간 별 최소 이동 비용을 구한다.
3. 구간 별 이동 비용을 합친다.

점화식
abs(i - j) < 2: dp[i][j] = 각각의 이동 거리
i < j: dp[i][j] = dp[i][k] + dp[k+1][j]
모든 노드, 모든 분할 구간에 대해서 최소 이동 거리를 구해서 dp에 저장.
최소 이동 비용을 가진 노드의 시작점이 선정됨

시간복잡도: O(N * K * log N)
공간복잡도: O(N^2) <-- dp 배열

Pseudo Code
matrix
dp = [[0] * N] * N

방문한 곳을 체크하는 것도 중요한데..

# dp 채워넣기
N을 순회 i:
    0부터 N까지 순회 j:

def traversal(i, j):
    거리가 1차이라면: return matrix[i][j]
    아니라면:
        k로 구간별로 나눠서 계산을 해오고, 그 결과들의 최소 비용을 반환한다.
        dp에 값이 있다면 가져다 쓰고, 계산된 결과는 새로 dp에 저장
        visited 등록
        자기 자신과 이미 방문한 노드를 제외한 최소 거리 선정

모든 노드에 대해서 traversal을 시행.
최소 비용이 든 결과를 출력

"""
